---
title: "Nand2Tetris読書会（0章）" # TODO 章番号を直す
emoji: "📚"
type: "idea"
topics: ["読書会", "勉強会"]
published: false # 公開するときはtrueに変える
---

# 概要

[Nand2Tetris読書会](https://zenn.dev/tomom1_s/articles/nand2tetris-00) を開催しています。
今回取り上げるのは、12章『オペレーションシステム』です。

前の記事は [こちら](https://zenn.dev/tomom1_s/articles/nand2tetris-11)。

# 内容

オペレーションシステム(OS)の役割:
- コンピュータのハードウェアとソフトウェアシステムのギャップを埋める
- プログラマーやユーザーにとってコンピュータ全体をより扱いやすくする

今回のOSで目指すのは以下の2つ。
- ハードウェアに特化したサービスをカプセル化  
→ ソフトウェアから使いやすいサービスに
- 高水準言語を、ファンクションと抽象データ型で拡張

本章で構築するOSは、標準ライブラリとの境界線が曖昧であり、OSをJackの標準ライブラリと捉えられる。

OSと他のプログラムの比較:

|              | 言語            | 実行されるハードウェアへの理解 |
|----|---|---|
| OS           | 高水準言語(Jack) | 必要 |
| 他のプログラム | 高水準言語(Jack) | 不要 |

本章のポイントは以下の2つ。
- ソフトウェアエンジニアリングの観点では、高水準言語、コンパイラ、OSを完成させる
- コンピュータサイエンスの観点では、サービスの効率さのために処理時間にも注意する

コンピュータシステムは、数学操作(加算、乗算、除算、etc.)をサポートしなければならない。
通常、加算はハードウェア(ALU)で行われるが、乗算と除算をハードウェアとソフトウェアのどちらで扱うかはコストとパフォーマンスに依存する。

乗算、除算、平方根をソフトウェアで効率良く計算するために、本章で紹介されるアルゴリズムをベースにできる。
数学アルゴリズムは、$n$ ビット($n$ = 16, 32, 64のどれか)のバイナリ数に対して処理をする。

例: 乗算( $x*y$ )
$x$ を $y$ 回足す
→ $n$ のサイズ($2^n$) $∝$ 処理時間
→ 時間がかかる
提案するアルゴリズムなら $n ∝$ 処理時間 とできる。

- 乗算  
  - 掛け算の筆算と同じ考え方で、バイナリも計算できる
  - プリミティブなALU操作で簡単に計算可能
  - 処理時間は $O(n)$
- 除算 ( $x/y$ )  
  - $x$ から大きい塊からなる $y$ を引く
  - 繰り返し処理において、最大のシフトをした $y$ で $x$ を割る
  - 処理時間は $O(n)$
- 平方根
  - 単調増加、逆関数は乗算であることから、二分探索で計算できる
  - 処理時間は $O(n)$

コンピュータは数をバイナリコードで表現するが、人間にとっては10進数で表現する方が自然。
そこで、人が数字を読む/入力するときに、10進数 ⇆ バイナリコード の変換をする必要がある。
一般的に、この変換はOSが提供する文字列ルーチンが行う。

- 文字列 → ASCIIコード
  - 文字列の表す数字にASCIIコードの `0` に相当する数字を加算
- ASCIIコード → 文字列
  - ASCIIコードの値からASCIIコードの `0` に相当する数字を減算

プログラムのライフサイクルでは、変数ごとにメモリに割り当てられるタイミングが異なる (動的メモリ割り当て)

例:
- スタティック変数は、コンパイラによってコンパイル時に割り当てられるかも
- ローカル変数は、サブルーチンが呼び出されるたびにスタック上に割り当てられる
- その他のメモリは、プログラム実行中に動的に割り当てられる

OSは、ヒープ (動的に割り当てられるRAMセグメント) を管理する責任を負う。
- 動的メモリの割り当て (`alloc()`)
- 動的メモリの破棄 (`deAlloc()`)
  - ガーベジコレクション: 配列やオブジェクトが不要になったとき、その配列やオブジェクト自動的に破棄する仕組み。代表的なのはJavaのGC。
  - GCを備えない言語では、使用しないメモリ領域の破棄作業はプログラマが明示的にやらないといけない。

銅的メモリの割り当て・破棄の関数について、簡易版と改善版のふたつのバージョンを考える。

- 簡易版メモリ割り当てアルゴリズム
  - `alloc`: まだ割り当てが行われていないヒープ領域の先頭を指すポインタを、指定されたサイズのメモリブロックの先頭に移す。
  - `deAlloc`: 何もしない。
- 改善版メモリ割り当てアルゴリズム  
メモリセグメントを、$freeList$ と呼ばれる連結リストで管理。
各セグメントは、自身のセグメントの長さ、リストの次のセグメントへのポインタの2つのフィールドを含む。
  - `alloc`: 指定されたサイズよりも長いセグメントを探索し、セグメントが見つかったら $freeList$ を更新する。  
  探索の際には、以下のどちらかのアルゴリズムを用いる。
    - best-fit: 指定されたサイズに最も近い長さのセグメントを見つける
    - first-fit: 指定されたサイズを満たす最初のセグメントを見つける
  - `deAlloc`: 指定されたオブジェクトを $freeList$ に追加する。

改善版メモリ割り当てプログラムでは、断片化(フラグメンテーション)が問題となる。
これは、利用可能なメモリ領域が細切れになることで、断片化を解消するには「デフラグ」という操作が必要となる。
デフラグにより、断片化の状態になったメモリ領域を $freeList$ の論理的に断片化されたセグメントではなく、物理的に連続したメモリ領域に結合できる。
デフラグは、オブジェクトを破棄するとき、あるいは `alloc()` 呼び出しで適切なセグメントが見つからなかったときに行える。

## 予習メモ

### big O-記法

予習をしたときに調べたことや気づいたことを書く

### 動的メモリ割り当て

スタティック変数がコンパイル時に割り当てが行われないのはどんなとき？

## ディスカッションメモ

### question1

# 感想

# 最後に

『[Nand2Tetris読書会始めました](https://zenn.dev/tomom1_s/articles/nand2tetris-00)』の記事でも紹介していますが、読み進めているのはこちらの本です。
https://www.oreilly.co.jp/books/9784873117126/

初学者なりに書籍やその他に調べた内容をまとめていますが、理解が足りておらず間違ったことを書いているかもしれません。
そのような箇所を見つけた場合はコメントなどで指摘していただけると助かります。

<!-- 次の記事は [こちら](https://zenn.dev/tomom1_s/articles/nand2tetris-99)。 -->
