---
title: "Nand2Tetris読書会（10章）"
emoji: "📚"
type: "idea"
topics: ["読書会", "勉強会"]
published: false # 公開するときはtrueに変える
---

# 概要

[Nand2Tetris読書会](https://zenn.dev/tomom1_s/articles/nand2tetris-00) を開催しています。
今回取り上げるのは、10章『コンパイラ#1：構文解析』です。

前の記事は [こちら](https://zenn.dev/tomom1_s/articles/nand2tetris-09)。

# 内容

「コンパイラ=変換を行うプログラム」であり、ソース言語で書かれたプログラムをターゲット言語で書かれたものに変換するプロセスをコンパイルと呼ぶ。
コンパイラの変換はふたつの作業に基づく。

1. 構文解析: ソースプログラムの構文を理解して、プログラムの意味(semantic)を明らかにする
1. コード生成: パースした情報から、ターゲット言語の構文からプログラムのロジックを再構成する

本章では、構文解析にスポットを当てて学習する。

構文解析の作業は、ふたつのモジュールに分けられる。

- トークナイザ: 「トークン」(意味を持つコードの最小単位)に変換する
- パーサ: 一連のトークンを言語の構文ルールに適合させて、構文構造を明らかにする

構文解析において、以下の4つがポイントとなる。

- 字句解析(スキャニング、トークン化)
  - プログラム内の文字のグループをトークンにまとめること。
  - トークンは、キーワード、シンボル、識別子、定値などの可能性がある。
- 文脈自由文法
  - ある言語の構文要素がより単純な要素からどのように構成されるかを指定したルールの集合のこと。
  - 宣言側の視点: トークン(終端要素、ターミナル) → 高水準な構文要素(非終端要素) → より高水準な非終端要素 → ... → トークンの集合 と組み合わせる。
  - 分析側の視点: トークンの集合 → 非終端要素 → より低水準な非終端要素 → ... → 終端要素 と分解する。
- 構文木(導出木)
  - 構文解析のパーサモジュールによって生成される出力のデータ構造のこと。
  - コンパイラによっては、木構造をコード生成やエラー報告にも利用する。
- 再帰降下アルゴリズム
  - 言語の文法で規定されるネスト化された構文を使って、トークンの列に再起的に構文解析をする。
  - Jack言語はLL(1)文法の言語なので、最初のトークンを見ればトークンの種類を決定できる。

本章のプロジェクトで作成する構文解析器は、コンパイル結果をXMLファイルとして出力する。
これにより、次章のプロジェクトではXMLファイル生成部をVMコード生成部に置き換えるだけでよくなる。

## 実装

本章では、3つのモジュールを使ってコンパイラを実装する。

- `JackAnalyzer`: セットアップや他モジュールの呼び出しをする
  1. 入力のJackファイル(`Xxx.lack`)から、`JackTokenizer` を生成。
  1. 出力用のファイル(`Xxx.xml`)を作り、出力結果を書き込む準備をする。
  1. 入力の `JackTokenizer` を出力ファイルへコンパイルするため、`CompilationEngine` を使う。
- `JackTokenizer`: トークナイザ
  1. 入力ストリームからすべてのコメントと空白文字を除去する。
  1. Jack文法に従ってJack言語のトークンへ分割する。
- `CompilationEngine`: 再帰によるトップダウン式の解析器
  1. `JackTokenizer` からの入力を受け取る。
  1. 構文解析の結果である木構造を出力ファイル/ストリームへ出力する。

## 予習メモ

### LL法とLR法

- [LL法](https://ja.wikipedia.org/wiki/LL法): 入力文字列を左端から構文解析して左端導出をする。構文木を、最上位の非終端要素(根に相当)からスタートして、順次右辺の要素列へと書き換えていく構文解析方法。
- [LR法](https://ja.wikipedia.org/wiki/LR法): 入力文字列を左端から構文解析して右端導出をする。構文木を、終端要素(葉に相当)からスタートして、順次左辺の非終端要素へと書き換えていき、最終的に最上位の非終端要素(根)を得る構文解析方法。

LL($k$)文法/LR($k$)文法とは、$k$字先のトークンを先読みする場合の表記であり、通常は $k=1$ なのでわざわざ表記しない。
$k$ が大きい言語はそれだけ先読みをすることになるので、構文解析が大変になる。

多くのプログラミング言語がLR法で構文解析でき、LR法の実装は非常に効率がよい。
ただ、LR構文解析器を自作するのは難しく、普通はコンパイラ生成器(パーサジェネレータ)を利用する。

### コンパイラ生成器

コンパイラの開発を支援するため、構文解析器を自動生成するプログラムのこと。

- LEX(lexical analysis):
レキシカルアナライザ(字句解析プログラム)を生成するプログラム(レキシカルアナライザジェネレータ)。実装で扱った `JackTokenizer` に相当するものを生成する。
- YACC(Yet Another Compiler Compiler):
構文解析器の解釈部分を生成するプログラム(パーサジェネレータ)。パーサジェネレータの中でも、[LALR](https://ja.wikipedia.org/wiki/LALR法)(1)の構文解析器を生成する。実装で扱った `CompilationEngine` に相当するものを生成する。

### 形式言語

書籍では、形式言語について「言語の特質や言語を規定するためのメタ言語と形式について議論する分野」とある。
「形式言語」とは特定の目的のために意図的に作られたプログラミング言語のような言語のことを指す言葉で、人間が日常的に用いる言語は時代や文化によって変化する「自然言語」とは逆の意味を持つ。
自然言語は話者同士の文脈に沿ったルールが存在しており曖昧さが許容されるが、形式言語は厳格なルールを持つ。

## ディスカッションメモ

### question1

# 感想

# 最後に

『[Nand2Tetris読書会始めました](https://zenn.dev/tomom1_s/articles/nand2tetris-00)』の記事でも紹介していますが、読み進めているのはこちらの本です。
https://www.oreilly.co.jp/books/9784873117126/

初学者なりに書籍やその他に調べた内容をまとめていますが、理解が足りておらず間違ったことを書いているかもしれません。
そのような箇所を見つけた場合はコメントなどで指摘していただけると助かります。

<!-- 次の記事は [こちら](https://zenn.dev/tomom1_s/articles/nand2tetris-11)。 -->
